diff -burN SDL2-2.0.1/configure.in SDL2-2.0.1-PS3/configure.in
--- SDL2-2.0.1/configure.in	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/configure.in	2013-12-06 22:07:45.955084385 -0500
@@ -1639,6 +1639,20 @@
     fi
 }
 
+dnl Set up the Null video driver.
+CheckPSL1GHTVideo()
+{
+    AC_ARG_ENABLE(video-psl1ght,
+AC_HELP_STRING([--enable-video-psl1ght], [use PSL1GHT video driver [[default=yes]]]),
+                  , enable_video_psl1ght=yes)
+    if test x$enable_video_psl1ght = xyes; then
+        AC_DEFINE(SDL_VIDEO_DRIVER_PSL1GHT, 1, [ ])
+        AC_DEFINE(SDL_VIDEO_RENDER_PSL1GHT, 1, [ ])
+        SOURCES="$SOURCES $srcdir/src/video/psl1ght/*.c"
+        have_video=yes
+    fi
+}
+
 dnl rcg04172001 Set up the Null video driver.
 CheckDummyVideo()
 {
@@ -2809,6 +2823,36 @@
             EXTRA_LDFLAGS="$EXTRA_LDFLAGS -Wl,-framework,CoreAudio -Wl,-framework,AudioToolbox -Wl,-framework,AudioUnit"
         fi
         ;;
+    powerpc64-ps3-elf)
+        ARCH=psl1ght
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -D__PSL1GHT__ -DHAVE_POW -DHAVE_MMAP=0 -DDEBUG_ERROR"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS -I\"$PSL1GHT/ppu/include\" -mcpu=cell "
+		EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lgcm_sys -lrsx -lsysutil -lio -laudio -lrt -llv2"
+        CheckPSL1GHTVideo
+        #CheckDummyAudio
+        # Set up files for the thread library
+        if test x$enable_threads = xyes; then
+            AC_DEFINE(SDL_THREAD_PSL1GHT)
+            SOURCES="$SOURCES $srcdir/src/thread/psl1ght/*.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_sysmutex.c"
+            SOURCES="$SOURCES $srcdir/src/thread/generic/SDL_syscond.c"
+            have_threads=yes
+        fi
+        # Set up files for the joystick library
+        if test x$enable_joystick = xyes; then
+            AC_DEFINE(SDL_JOYSTICK_PSL1GHT)
+            SOURCES="$SOURCES $srcdir/src/joystick/psl1ght/*.c"
+			EXTRA_LDFLAGS="$EXTRA_LDFLAGS -lio"
+            have_joystick=yes
+        fi
+        # Set up files for the audio library
+        if test x$enable_audio = xyes; then
+            AC_DEFINE(SDL_AUDIO_DRIVER_PSL1GHT)
+            SOURCES="$SOURCES $srcdir/src/audio/psl1ght/*.c"
+			EXTRA_LDFLAGS="$EXTRA_LDFLAGS -laudio"
+            have_audio=yes
+        fi
+		;;
     *)
         AC_MSG_ERROR([
 *** Unsupported host:  Please add to configure.in
diff -burN SDL2-2.0.1/include/SDL_config.h SDL2-2.0.1-PS3/include/SDL_config.h
--- SDL2-2.0.1/include/SDL_config.h	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/include/SDL_config.h	2013-12-06 22:08:11.396806025 -0500
@@ -39,6 +39,8 @@
 #include "SDL_config_android.h"
 #elif defined(__PSP__)
 #include "SDL_config_psp.h"
+#elif defined(__PSL1GHT__)
+#include "SDL_config_psl1ght.h"
 #else
 /* This is a minimal configuration just to get SDL running on new platforms */
 #include "SDL_config_minimal.h"
diff -burN SDL2-2.0.1/include/SDL_config.h.in SDL2-2.0.1-PS3/include/SDL_config.h.in
--- SDL2-2.0.1/include/SDL_config.h.in	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/include/SDL_config.h.in	2013-12-06 22:07:45.956084374 -0500
@@ -151,7 +151,9 @@
 #undef HAVE_SA_SIGACTION
 #undef HAVE_SETJMP
 #undef HAVE_NANOSLEEP
+#ifndef __PSL1GHT__ // Yeah PSL1GHT hasn't sysconf
 #undef HAVE_SYSCONF
+#endif
 #undef HAVE_SYSCTLBYNAME
 #undef HAVE_CLOCK_GETTIME
 #undef HAVE_GETPAGESIZE
@@ -209,6 +211,7 @@
 #undef SDL_AUDIO_DRIVER_OSS
 #undef SDL_AUDIO_DRIVER_OSS_SOUNDCARD_H
 #undef SDL_AUDIO_DRIVER_PAUDIO
+#undef SDL_AUDIO_DRIVER_PSL1GHT
 #undef SDL_AUDIO_DRIVER_QSA
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WINMM
@@ -227,6 +230,7 @@
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
+#undef SDL_JOYSTICK_PSL1GHT
 #undef SDL_HAPTIC_DUMMY
 #undef SDL_HAPTIC_LINUX
 #undef SDL_HAPTIC_IOKIT
@@ -241,6 +245,7 @@
 
 /* Enable various threading systems */
 #undef SDL_THREAD_BEOS
+#undef SDL_THREAD_PSL1GHT
 #undef SDL_THREAD_PTHREAD
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
@@ -249,6 +254,7 @@
 /* Enable various timer systems */
 #undef SDL_TIMER_BEOS
 #undef SDL_TIMER_DUMMY
+#undef SDL_TIMER_PSL1GHT
 #undef SDL_TIMER_UNIX
 #undef SDL_TIMER_WINDOWS
 
@@ -258,6 +264,7 @@
 #undef SDL_VIDEO_DRIVER_DIRECTFB
 #undef SDL_VIDEO_DRIVER_DIRECTFB_DYNAMIC
 #undef SDL_VIDEO_DRIVER_DUMMY
+#undef SDL_VIDEO_DRIVER_PSL1GHT
 #undef SDL_VIDEO_DRIVER_WINDOWS
 #undef SDL_VIDEO_DRIVER_X11
 #undef SDL_VIDEO_DRIVER_RPI
@@ -287,6 +294,7 @@
 #undef SDL_VIDEO_RENDER_OGL_ES
 #undef SDL_VIDEO_RENDER_OGL_ES2
 #undef SDL_VIDEO_RENDER_DIRECTFB
+#undef SDL_VIDEO_RENDER_PSL1GHT
 
 /* Enable OpenGL support */
 #undef SDL_VIDEO_OPENGL
diff -burN SDL2-2.0.1/include/SDL_config_psl1ght.h SDL2-2.0.1-PS3/include/SDL_config_psl1ght.h
--- SDL2-2.0.1/include/SDL_config_psl1ght.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/include/SDL_config_psl1ght.h	2013-12-06 22:08:16.927745537 -0500
@@ -0,0 +1,158 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _SDL_config_psl1ght_h
+#define _SDL_config_psl1ght_h
+
+/**
+ *  \file SDL_config.h.in
+ *
+ *  This is a set of defines to configure the SDL features
+ */
+
+#include "SDL_platform.h"
+
+
+
+#ifdef __GNUC__
+#define HAVE_GCC_SYNC_LOCK_TEST_AND_SET 1
+#endif
+
+#define SIZEOF_VOIDP 8
+#define HAVE_GCC_ATOMICS    1
+
+/* Comment this if you want to build without any C library requirements */
+#define HAVE_LIBC 1
+
+#if HAVE_LIBC
+#define HAVE_ALLOCA_H       1
+#define HAVE_SYS_TYPES_H    1
+#define HAVE_STDIO_H    1
+#define STDC_HEADERS    1
+#define HAVE_STDLIB_H   1
+#define HAVE_STDARG_H   1
+#define HAVE_STRING_H   1
+#define HAVE_STRINGS_H  1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H   1
+#define HAVE_CTYPE_H    1
+#define HAVE_MATH_H     1
+#define HAVE_ICONV_H    1
+#define HAVE_SIGNAL_H   1
+#define HAVE_ALTIVEC_H  1
+
+/* C library functions */
+#define HAVE_MALLOC 1
+#define HAVE_CALLOC 1
+#define HAVE_REALLOC    1
+#define HAVE_FREE   1
+#define HAVE_ALLOCA 1
+#ifndef __WIN32__ /* Don't use C runtime versions of these on Windows */
+#define HAVE_GETENV 1
+#define HAVE_SETENV 1
+#define HAVE_PUTENV 1
+#define HAVE_UNSETENV   1
+#endif
+#define HAVE_QSORT  1
+#define HAVE_ABS    1
+#define HAVE_BCOPY  1
+#define HAVE_MEMSET 1
+#define HAVE_MEMCPY 1
+#define HAVE_MEMMOVE    1
+/* #undef HAVE_MEMCMP */
+#define HAVE_STRLEN 1
+#define HAVE_STRLCPY    1
+#define HAVE_STRLCAT    1
+#define HAVE_STRDUP 1
+#define HAVE_STRCHR 1
+#define HAVE_STRRCHR    1
+#define HAVE_STRSTR 1
+#define HAVE_STRTOL 1
+#define HAVE_STRTOUL    1
+#define HAVE_STRTOLL    1
+#define HAVE_STRTOULL   1
+/* #undef HAVE_STRTOD */
+#define HAVE_ATOI   1
+#define HAVE_ATOF   1
+#define HAVE_STRCMP 1
+#define HAVE_STRNCMP    1
+#define HAVE_STRCASECMP 1
+#define HAVE_STRNCASECMP 1
+#define HAVE_SSCANF 1
+#define HAVE_SNPRINTF   1
+#define HAVE_VSNPRINTF  1
+#define HAVE_M_PI   1
+#define HAVE_ATAN   1
+#define HAVE_ATAN2  1
+#define HAVE_CEIL   1
+#define HAVE_COPYSIGN   1
+#define HAVE_COS    1
+#define HAVE_COSF   1
+#define HAVE_FABS   1
+#define HAVE_FLOOR  1
+#define HAVE_LOG    1
+/* #undef HAVE_POW  */
+#define HAVE_SCALBN 1
+#define HAVE_SIN    1
+#define HAVE_SINF   1
+#define HAVE_SQRT   1
+#define HAVE_SETJMP 1
+/* #undef HAVE_NANOSLEEP */
+/* #define HAVE_SYSCONF  1 */
+/* #define HAVE_SIGACTION    1 */
+
+#else
+#include <stdarg.h>
+#endif /* HAVE_LIBC */
+
+/* PSP isn't that sophisticated */
+/* #define LACKS_SYS_MMAN_H 1 */
+
+/* Enable the stub for HAPTIC
+/* PS3 doesn't have haptic device (src/haptic/dummy/\*.c) */
+#define SDL_HAPTIC_DISABLED    1
+
+/* PS3 can't load shared object (src/loadso/dummy/\*.c) */
+#define SDL_LOADSO_DISABLED    1
+
+/* Enable the stub audio driver (src/audio/psp/\*.c) */
+#define SDL_AUDIO_DRIVER_PSL1GHT    1
+
+/* Enable the stub joystick driver (src/joystick/psp/\*.c) */
+#define SDL_JOYSTICK_PSL1GHT        1
+
+/* Enable the stub thread support (src/thread/psp/\*.c) */
+#define SDL_THREAD_PSL1GHT  1
+
+/* Enable the stub timer support (src/timer/psp/\*.c) */
+#define SDL_TIMER_PSL1GHT  1
+
+/* PS3 video dirver */
+#define SDL_VIDEO_DRIVER_PSL1GHT   1
+
+/* PS3 render dirver */
+#define SDL_VIDEO_RENDER_PSL1GHT   1
+
+/* Enable assembly routines */
+#define SDL_ASSEMBLY_ROUTINES 1
+#define SDL_ALTIVEC_BLITTERS 1
+
+#endif /* _SDL_config_psl1ght_h */
diff -burN SDL2-2.0.1/include/SDL_platform.h SDL2-2.0.1-PS3/include/SDL_platform.h
--- SDL2-2.0.1/include/SDL_platform.h	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/include/SDL_platform.h	2013-12-06 22:07:45.956084374 -0500
@@ -132,6 +132,10 @@
 #undef __PSP__
 #define __PSP__ 1
 #endif
+#if defined(__PSL1GHT__)
+#undef __PSL1GHT__
+#define __PSL1GHT__  1
+#endif
 
 #include "begin_code.h"
 /* Set up for C function definitions, even when using C++ */
diff -burN SDL2-2.0.1/README.PSL1GHT SDL2-2.0.1-PS3/README.PSL1GHT
--- SDL2-2.0.1/README.PSL1GHT	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/README.PSL1GHT	2013-12-06 22:07:45.957084364 -0500
@@ -0,0 +1,14 @@
+
+HowTo Build:
+
+You need to build SDL:
+- ooPo's ps3toolchain : https://github.com/ps3dev/ps3toolchain
+- the PSL1GHT SDK : https://github.com/ps3dev/PSL1GHT.git
+- possibly ooPo's ps3libraries : https://github.com/ps3dev/ps3libraries
+
+Run the script.sh to configure SDL
+
+Run make & make install afterthat
+
+
+To built up your source use the -lSDL -lm switches
diff -burN SDL2-2.0.1/src/audio/psl1ght/SDL_psl1ghtaudio.c SDL2-2.0.1-PS3/src/audio/psl1ght/SDL_psl1ghtaudio.c
--- SDL2-2.0.1/src/audio/psl1ght/SDL_psl1ghtaudio.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/audio/psl1ght/SDL_psl1ghtaudio.c	2013-12-06 22:07:45.958084353 -0500
@@ -0,0 +1,214 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+
+    This file written by Ryan C. Gordon (icculus@icculus.org)
+*/
+#include "SDL_config.h"
+
+/* Output audio to PSL1GHT */
+
+#include "SDL.h"
+
+
+#include "SDL_audio.h"
+#include "../SDL_audio_c.h"
+#include "SDL_psl1ghtaudio.h"
+
+#define SHW64(X) (u32)(((u64)X)>>32), (u32)(((u64)X)&0xFFFFFFFF)
+
+#define AUDIO_DEBUG
+
+#ifdef AUDIO_DEBUG
+#define deprintf(...) printf(__VA_ARGS__)
+#else
+#define deprintf(...)
+#endif
+
+static int
+PSL1GHT_AUD_OpenDevice(_THIS, const char *devname, int iscapture)
+{
+	deprintf( "PSL1GHT_AUD_OpenDevice(%08X.%08X, %s, %d)\n", SHW64(this), devname, iscapture);
+    SDL_AudioFormat test_format = SDL_FirstAudioFormat(this->spec.format);
+    int valid_datatype = 0;
+
+    this->hidden = SDL_malloc(sizeof(*(this->hidden)));
+    if (!this->hidden) {
+        SDL_OutOfMemory();
+        return 0;
+    }
+    SDL_memset(this->hidden, 0, (sizeof *this->hidden));
+
+
+	// PS3 Libaudio only handles floats
+    while ((!valid_datatype) && (test_format)) {
+        this->spec.format = test_format;
+        switch (test_format) {
+        case AUDIO_F32MSB:
+            valid_datatype = 1;
+            break;
+        default:
+            test_format = SDL_NextAudioFormat();
+            break;
+        }
+    }
+
+    int ret=audioInit();
+
+	//set some parameters we want
+	//either 2 or 8 channel
+	_params.numChannels = AUDIO_PORT_2CH;
+	//8 16 or 32 block buffer
+	_params.numBlocks = AUDIO_BLOCK_8;
+	//extended attributes
+	_params.attrib = 0;
+	//sound level (1 is default)
+	_params.level = 1;
+
+	ret=audioPortOpen(&_params, &_portNum);
+	deprintf("audioPortOpen: %d\n",ret);
+	deprintf("  portNum: %d\n",_portNum);
+
+	ret=audioGetPortConfig(_portNum, &_config);
+	deprintf("audioGetPortConfig: %d\n",ret);
+	deprintf("  readIndex: 0x%8X\n",_config.readIndex);
+	deprintf("  status: %d\n",_config.status);
+	deprintf("  channelCount: %ld\n",_config.channelCount);
+	deprintf("  numBlocks: %ld\n",_config.numBlocks);
+	deprintf("  portSize: %d\n",_config.portSize);
+	deprintf("  audioDataStart: 0x%8X\n",_config.audioDataStart);
+
+	// create an event queue that will tell when a block is read
+	ret=audioCreateNotifyEventQueue( &_snd_queue, &_snd_queue_key);
+	printf("audioCreateNotifyEventQueue: %d\n",ret);
+
+	// Set it to the sprx
+	ret = audioSetNotifyEventQueue(_snd_queue_key);
+	printf("audioSetNotifyEventQueue: %d\n",ret);
+
+	// clears the event queue
+	ret = sysEventQueueDrain(_snd_queue);
+	printf("sysEentQueueDrain: %d\n",ret);
+
+	ret=audioPortStart(_portNum);
+	deprintf("audioPortStart: %d\n",ret);
+
+	_last_filled_buf = _config.numBlocks - 1;
+
+	this->spec.format = test_format;
+	this->spec.size = sizeof(float) * AUDIO_BLOCK_SAMPLES * _config.channelCount;
+	this->spec.freq = 48000;
+	this->spec.samples = AUDIO_BLOCK_SAMPLES;
+	this->spec.channels = _config.channelCount;
+
+    return ret == 0;
+}
+
+static void
+PSL1GHT_AUD_PlayDevice(_THIS)
+{
+	deprintf( "PSL1GHT_AUD_PlayDevice(%08X.%08X)\n", SHW64(this));
+	
+	/*
+	while( _config.readIndex == _last_filled_buf) // FIXME this is a mess to remove when queued event will me integrated
+	{
+		deprintf( "\tplaying too fast... waiting a ms\n");
+		//sleep(1);
+	}*/
+    /*TransferSoundData *sound = SDL_malloc(sizeof(TransferSoundData));
+    if (!sound) {
+        SDL_OutOfMemory();
+    }
+
+    playGenericSound(this->hidden->mixbuf, this->hidden->mixlen);*/
+}
+
+
+static void
+PSL1GHT_AUD_CloseDevice(_THIS)
+{
+	deprintf( "PSL1GHT_AUD_CloseDevice(%08X.%08X)\n", SHW64(this));
+	int ret = 0;
+	ret=audioPortStop(_portNum);
+	deprintf("audioPortStop: %d\n",ret);
+	ret=audioRemoveNotifyEventQueue(_snd_queue_key);
+	deprintf("audioRemoveNotifyEventQueue: %d\n",ret);
+	ret=audioPortClose(_portNum);
+	deprintf("audioPortClose: %d\n",ret);
+	ret=sysEventQueueDestroy(_snd_queue, 0);
+	deprintf("sysEventQueueDestroy: %d\n",ret);
+	ret=audioQuit();
+	deprintf("audioQuit: %d\n",ret);
+
+    SDL_free(this->hidden);
+}
+
+static Uint8 *
+PSL1GHT_AUD_GetDeviceBuf(_THIS)
+{
+	
+	//deprintf( "PSL1GHT_AUD_GetDeviceBuf(%08X.%08X) at %d ms\n", SHW64(this), SDL_GetTicks());
+
+    //int playing = _config.readIndex;
+    int playing = *((u64*)(u64)_config.readIndex);
+    int filling = (_last_filled_buf + 1) % _config.numBlocks;
+	Uint8 * dma_buf = (Uint8 *)(u64)_config.audioDataStart;
+	//deprintf( "\tWriting to buffer %d \n", filling);
+	// deprintf( "\tbuffer address (%08X.%08X => %08X.%08X)\n", SHW64(_config.audioDataStart), SHW64(dma_buf));
+
+	_last_filled_buf = filling;
+    return (dma_buf + (filling * this->spec.size));
+}
+
+/* This function waits until it is possible to write a full sound buffer */
+static void
+ALSA_WaitDevice(_THIS)
+{
+    /* We're in blocking mode, so there's nothing to do here */
+	//deprintf( "ALSA_WaitDevice(%08X.%08X)\n", SHW64(this));
+	
+	sys_event_t event;
+	s32 ret = sysEventQueueReceive( _snd_queue, &event, 20 * 1000);
+	//deprintf( "sysEventQueueReceive: %08X\n", ret);
+}
+
+
+	static int
+PSL1GHT_AUD_Init(SDL_AudioDriverImpl * impl)
+{
+	deprintf( "PSL1GHT_AUD_Init(%08X.%08X)\n", SHW64(impl));
+	/* Set the function pointers */
+	impl->OpenDevice = PSL1GHT_AUD_OpenDevice;
+	//impl->PlayDevice = PSL1GHT_AUD_PlayDevice;
+    impl->WaitDevice = ALSA_WaitDevice;
+	impl->CloseDevice = PSL1GHT_AUD_CloseDevice;
+	impl->GetDeviceBuf = PSL1GHT_AUD_GetDeviceBuf;
+
+    /* and the capabilities */
+    impl->OnlyHasDefaultOutputDevice = 1;
+
+    return 1;   /* this audio target is available. */
+}
+
+AudioBootStrap PSL1GHT_AUD_bootstrap = {
+    "psl1ght", "SDL PSL1GHT audio driver", PSL1GHT_AUD_Init, 0       /*1? */
+};
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/audio/psl1ght/SDL_psl1ghtaudio.h SDL2-2.0.1-PS3/src/audio/psl1ght/SDL_psl1ghtaudio.h
--- SDL2-2.0.1/src/audio/psl1ght/SDL_psl1ghtaudio.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/audio/psl1ght/SDL_psl1ghtaudio.h	2013-12-06 22:07:45.958084353 -0500
@@ -0,0 +1,52 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#pragma once
+
+#include "../SDL_sysaudio.h"
+
+#include <audio/audio.h>
+/* Hidden "this" pointer for the audio functions */
+#define _THIS	SDL_AudioDevice *this
+
+struct SDL_PrivateAudioData
+{
+    //:TransferSoundData *sound;
+    /* The file descriptor for the audio device */
+
+	audioPortParam params;
+	audioPortConfig config;
+	u32 portNum;
+	u32 last_filled_buf;
+	sys_event_queue_t snd_queue; // Queue identifier
+	u64	snd_queue_key; // Queue Key
+};
+
+#define _params this->hidden->params
+#define _config this->hidden->config
+#define _portNum this->hidden->portNum
+#define _last_filled_buf this->hidden->last_filled_buf
+#define _snd_queue  this->hidden->snd_queue 
+#define _snd_queue_key this->hidden->snd_queue_key
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/audio/SDL_audio.c SDL2-2.0.1-PS3/src/audio/SDL_audio.c
--- SDL2-2.0.1/src/audio/SDL_audio.c	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/audio/SDL_audio.c	2013-12-06 22:07:45.959084342 -0500
@@ -67,6 +67,7 @@
 extern AudioBootStrap FUSIONSOUND_bootstrap;
 extern AudioBootStrap ANDROIDAUD_bootstrap;
 extern AudioBootStrap PSPAUD_bootstrap;
+extern AudioBootStrap PSL1GHT_AUD_bootstrap;
 extern AudioBootStrap SNDIO_bootstrap;
 
 /* Available audio drivers */
@@ -134,6 +135,9 @@
 #if SDL_AUDIO_DRIVER_PSP
     &PSPAUD_bootstrap,
 #endif
+#if SDL_AUDIO_DRIVER_PSL1GHT
+    &PSL1GHT_AUD_bootstrap,
+#endif
     NULL
 };
 
diff -burN SDL2-2.0.1/src/events/SDL_gesture.c SDL2-2.0.1-PS3/src/events/SDL_gesture.c
--- SDL2-2.0.1/src/events/SDL_gesture.c	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/events/SDL_gesture.c	2013-12-06 22:07:45.959084342 -0500
@@ -27,7 +27,7 @@
 #include "SDL_events_c.h"
 #include "SDL_gesture_c.h"
 
-#if !defined(__PSP__)
+#if !defined(__PSP__) && !defined(__PSL1GHT__)
 #include <memory.h>
 #endif
 
diff -burN SDL2-2.0.1/src/joystick/psl1ght/SDL_sysjoystick.c SDL2-2.0.1-PS3/src/joystick/psl1ght/SDL_sysjoystick.c
--- SDL2-2.0.1/src/joystick/psl1ght/SDL_sysjoystick.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/joystick/psl1ght/SDL_sysjoystick.c	2013-12-06 22:07:45.960084331 -0500
@@ -0,0 +1,268 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_PSL1GHT
+
+/* This is the system specific header for the SDL joystick API */
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <io/pad.h>
+
+#define pdprintf(x) printf(x)
+
+#define NAMESIZE 10
+
+typedef struct SDL_PSL1GHT_JoyData
+{
+	char name[NAMESIZE];
+} SDL_PSL1GHT_JoyData;
+
+struct joystick_hwdata
+{
+	padData old_pad_data;
+};
+
+static int SDL_SYS_numjoysticks = 0;
+    
+static SDL_PSL1GHT_JoyData joy_data[MAX_PADS];
+
+
+
+/* Function to scan the system for joysticks.
+ * This function should set SDL_numjoysticks to the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return 0, or -1 on an unrecoverable fatal error.
+ */
+int
+SDL_SYS_JoystickInit(void)
+{
+	int iReturn = 0;
+    SDL_SYS_numjoysticks = 0;
+	padInfo padinfo;
+
+	pdprintf("SDL_SYS_JoystickInit\n");
+
+	SDL_zero( joy_data);
+
+	iReturn =  ioPadInit( MAX_PADS) ;
+	pdprintf("\tPad initialized\n");
+	if( iReturn != 0)
+	{
+		SDL_SetError("SDL_SYS_JoystickInit() : Couldn't initialize PS3 pads");
+	}
+
+	if( iReturn == 0)
+	{
+		iReturn = ioPadGetInfo(&padinfo);
+		pdprintf("\tGot info\n");
+		if( iReturn != 0)
+		{
+			SDL_SetError("SDL_SYS_JoystickInit() : Couldn't get PS3 pads information ");
+		}
+	}
+
+	if( iReturn == 0)
+	{
+		unsigned int i;
+		SDL_SYS_numjoysticks = padinfo.connected;
+
+		for(i = 0; i < padinfo.connected; i++)
+		{
+			if( padinfo.status[i])
+			{
+				sprintf( joy_data[i].name, "PAD%02X", i);
+			}
+		} 
+	}
+    return SDL_SYS_numjoysticks;
+}
+
+int SDL_SYS_NumJoysticks()
+{
+    return SDL_SYS_numjoysticks;
+}
+
+void SDL_SYS_JoystickDetect()
+{
+}
+
+SDL_bool SDL_SYS_JoystickNeedsPolling()
+{
+    return SDL_FALSE;
+}
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickNameForDeviceIndex(int device_index)
+{
+	char * name = NULL;
+	if( device_index < SDL_SYS_numjoysticks)
+		name = joy_data[device_index].name;
+	else
+		SDL_SetError("No joystick available with that index");
+    return name;
+}
+
+/* Function to perform the mapping from device index to the instance id for this index */
+SDL_JoystickID SDL_SYS_GetInstanceIdOfDeviceIndex(int device_index)
+{
+    return device_index;
+}
+
+/* Function to open a joystick for use.
+   The joystick to open is specified by the index field of the joystick.
+   This should fill the nbuttons and naxes fields of the joystick structure.
+   It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick * joystick, int device_index)
+{
+    joystick->instance_id = device_index;
+    joystick->hwdata = SDL_malloc(sizeof(struct joystick_hwdata));
+    if (joystick->hwdata == NULL) {
+        SDL_OutOfMemory();
+        return (-1);
+    }
+    SDL_memset(joystick->hwdata, 0, sizeof(*joystick->hwdata));
+
+	joystick->naxes = 4;
+	joystick->nhats = 0;
+	joystick->nballs = 0;
+	joystick->nbuttons = 16;
+
+    return 0;
+}
+
+/* Function to determine is this joystick is attached to the system right now */
+SDL_bool SDL_SYS_JoystickAttached(SDL_Joystick *joystick)
+{
+    return SDL_TRUE;
+}
+
+
+#define CheckPSL1GHTAxis( btn, bnum) \
+	if( new_pad_data.btn != joystick->hwdata->old_pad_data.btn) {\
+		SDL_PrivateJoystickAxis( joystick, (bnum), ((new_pad_data.btn-0x80)<<8)|new_pad_data.btn); \
+	} \
+	joystick->hwdata->old_pad_data.btn = new_pad_data.btn;
+
+#define CheckPSL1GHTButton( btn, bnum) \
+	if( new_pad_data.btn != joystick->hwdata->old_pad_data.btn) {\
+		if( new_pad_data.btn == 0) \
+		SDL_PrivateJoystickButton( joystick, (bnum), SDL_RELEASED); \
+		else \
+		SDL_PrivateJoystickButton( joystick, (bnum), SDL_PRESSED); \
+	} \
+	joystick->hwdata->old_pad_data.btn = new_pad_data.btn;
+
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+void
+SDL_SYS_JoystickUpdate(SDL_Joystick * joystick)
+{
+	padData new_pad_data;
+	if( ioPadGetData(joystick->instance_id, &new_pad_data) != 0)
+		SDL_SetError("No joystick available with that index");
+	else if(new_pad_data.len >= 8)
+	{
+		// Update axes
+		CheckPSL1GHTAxis( ANA_L_H, 0);
+		CheckPSL1GHTAxis( ANA_L_V, 1);
+		CheckPSL1GHTAxis( ANA_R_H, 2);
+		CheckPSL1GHTAxis( ANA_R_V, 3);
+		
+		// Update buttons
+		CheckPSL1GHTButton( BTN_LEFT, 0);
+		CheckPSL1GHTButton( BTN_DOWN, 1);
+		CheckPSL1GHTButton( BTN_RIGHT, 2);
+		CheckPSL1GHTButton( BTN_UP, 3);
+
+		CheckPSL1GHTButton( BTN_START, 4);
+		CheckPSL1GHTButton( BTN_R3, 5);
+		CheckPSL1GHTButton( BTN_L3, 6);
+		CheckPSL1GHTButton( BTN_SELECT, 7);
+
+		CheckPSL1GHTButton( BTN_SQUARE, 8);
+		CheckPSL1GHTButton( BTN_CROSS, 9);
+		CheckPSL1GHTButton( BTN_CIRCLE, 10);
+		CheckPSL1GHTButton( BTN_TRIANGLE, 11);
+
+		CheckPSL1GHTButton( BTN_R1, 12);
+		CheckPSL1GHTButton( BTN_L1, 13);
+		CheckPSL1GHTButton( BTN_R2, 14);
+		CheckPSL1GHTButton( BTN_L2, 15);
+	}
+
+    return;
+}
+
+/* Function to close a joystick after use */
+void
+SDL_SYS_JoystickClose(SDL_Joystick * joystick)
+{
+    if (joystick->hwdata) {
+        SDL_free(joystick->hwdata);
+        joystick->hwdata = NULL;
+    }
+
+    return;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void
+SDL_SYS_JoystickQuit(void)
+{
+    SDL_SYS_numjoysticks = 0;
+    return;
+}
+
+
+SDL_JoystickGUID SDL_SYS_JoystickGetDeviceGUID( int device_index )
+{
+    SDL_JoystickGUID guid;
+    // the GUID is just the first 16 chars of the name for now
+    const char *name = SDL_SYS_JoystickNameForDeviceIndex( device_index );
+    SDL_zero( guid );
+    SDL_memcpy( &guid, name, SDL_min( sizeof(guid), SDL_strlen( name ) ) );
+    return guid;
+}
+
+SDL_JoystickGUID SDL_SYS_JoystickGetGUID(SDL_Joystick * joystick)
+{
+    SDL_JoystickGUID guid;
+    // the GUID is just the first 16 chars of the name for now
+    const char *name = joystick->name;
+    SDL_zero( guid );
+    SDL_memcpy( &guid, name, SDL_min( sizeof(guid), SDL_strlen( name ) ) );
+    return guid;
+}
+
+#endif /* SDL_JOYSTICK_PSL1GHT */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/render/psl1ght/SDL_PSL1GHTrender.c SDL2-2.0.1-PS3/src/render/psl1ght/SDL_PSL1GHTrender.c
--- SDL2-2.0.1/src/render/psl1ght/SDL_PSL1GHTrender.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/render/psl1ght/SDL_PSL1GHTrender.c	2013-12-06 22:07:45.961084320 -0500
@@ -0,0 +1,678 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2011 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+#include "SDL_config.h"
+
+#if SDL_VIDEO_RENDER_PSL1GHT
+
+#include "../SDL_sysrender.h"
+#include "../../video/SDL_sysvideo.h"
+#include "../../video/psl1ght/SDL_PSL1GHTvideo.h"
+
+#include "../software/SDL_draw.h"
+#include "../software/SDL_blendfillrect.h"
+#include "../software/SDL_blendline.h"
+#include "../software/SDL_blendpoint.h"
+#include "../software/SDL_drawline.h"
+#include "../software/SDL_drawpoint.h"
+
+#include <rsx/rsx.h>
+#include <unistd.h>
+#include <assert.h>
+
+/* SDL surface based renderer implementation */
+
+static SDL_Renderer *PSL1GHT_CreateRenderer(SDL_Window * window, Uint32 flags);
+static int PSL1GHT_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+static int PSL1GHT_SetTextureColorMod(SDL_Renderer * renderer,
+                                 SDL_Texture * texture);
+static int PSL1GHT_SetTextureAlphaMod(SDL_Renderer * renderer,
+                                 SDL_Texture * texture);
+static int PSL1GHT_SetTextureBlendMode(SDL_Renderer * renderer,
+                                  SDL_Texture * texture);
+static int PSL1GHT_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                            const SDL_Rect * rect, const void *pixels,
+                            int pitch);
+static int PSL1GHT_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                          const SDL_Rect * rect, void **pixels, int *pitch);
+static void PSL1GHT_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+static int PSL1GHT_UpdateViewport(SDL_Renderer * renderer);
+static int PSL1GHT_RenderClear(SDL_Renderer * renderer);
+static int PSL1GHT_RenderDrawPoints(SDL_Renderer * renderer,
+                               const SDL_FPoint * points, int count);
+static int PSL1GHT_RenderDrawLines(SDL_Renderer * renderer,
+                              const SDL_FPoint * points, int count);
+static int PSL1GHT_RenderFillRects(SDL_Renderer * renderer,
+                              const SDL_FRect * rects, int count);
+static int PSL1GHT_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
+                         const SDL_Rect * srcrect, const SDL_FRect * dstrect);
+static int PSL1GHT_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                               Uint32 format, void * pixels, int pitch);
+static void PSL1GHT_RenderPresent(SDL_Renderer * renderer);
+static void PSL1GHT_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture);
+static void PSL1GHT_DestroyRenderer(SDL_Renderer * renderer);
+
+
+SDL_RenderDriver PSL1GHT_RenderDriver = {
+    PSL1GHT_CreateRenderer,
+    {
+     "PSL1GHT",
+     SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC,
+     1,
+     { SDL_PIXELFORMAT_ARGB8888 },
+     0,
+     0}
+};
+
+typedef struct
+{
+    bool first_fb; // Is this the first flip ?
+    int current_screen;
+    SDL_Surface *screens[3];
+    void *textures[3];
+    gcmContextData *context; // Context to keep track of the RSX buffer.
+} PSL1GHT_RenderData;
+
+static void waitFlip()
+{
+    while (gcmGetFlipStatus() != 0)
+      usleep(200);
+    gcmResetFlipStatus();
+}
+
+static SDL_Surface *
+PSL1GHT_ActivateRenderer(SDL_Renderer * renderer)
+{
+    PSL1GHT_RenderData *data = (PSL1GHT_RenderData *) renderer->driverdata;
+
+    return data->screens[data->current_screen];
+}
+
+SDL_Renderer *
+PSL1GHT_CreateRenderer(SDL_Window * window, Uint32 flags)
+{
+    SDL_Renderer *renderer;
+    PSL1GHT_RenderData *data;
+    SDL_VideoDisplay *display = SDL_GetDisplayForWindow(window);
+    SDL_DisplayMode *displayMode = &display->current_mode;
+    int i, n;
+    int bpp;
+    int pitch;
+    Uint32 Rmask, Gmask, Bmask, Amask;
+
+    if (!SDL_PixelFormatEnumToMasks(displayMode->format, &bpp,
+                                    &Rmask, &Gmask, &Bmask, &Amask)) {
+        SDL_SetError("Unknown display format");
+        return NULL;
+    }
+
+    renderer = (SDL_Renderer *) SDL_calloc(1, sizeof(*renderer));
+    if (!renderer) {
+        SDL_OutOfMemory();
+        return NULL;
+    }
+
+    data = (PSL1GHT_RenderData *) SDL_calloc(1, sizeof(*data));
+    if (!data) {
+        PSL1GHT_DestroyRenderer(renderer);
+        SDL_OutOfMemory();
+        return NULL;
+    }
+    
+    SDL_zerop(data);
+    
+    deprintf (1, "\tMem allocated\n");
+    
+    // Get a copy of the command buffer
+    data->context = ((SDL_DeviceData*) display->device->driverdata)->_CommandBuffer;
+    data->current_screen = 0;
+    data->first_fb = true;
+    
+    pitch = displayMode->w * SDL_BYTESPERPIXEL(displayMode->format);
+    
+    n = 2;
+    deprintf (1, "\tCreate the %d screen(s):\n", n);
+    for (i = 0; i < n; ++i) {
+        deprintf (1,  "\t\tAllocate RSX memory for pixels\n");
+        /* Allocate RSX memory for pixels */
+        data->textures[i] = rsxMemalign(64, displayMode->h * pitch);
+        if (!data->textures[i]) {
+            deprintf (1, "ERROR\n");
+            PSL1GHT_DestroyRenderer(renderer);
+            SDL_OutOfMemory();
+            return NULL;
+        }
+
+        memset(data->textures[i], 0, displayMode->h * pitch);
+
+        deprintf (1,  "\t\tSDL_CreateRGBSurfaceFrom( w: %d, h: %d)\n", displayMode->w, displayMode->h);
+        data->screens[i] =
+            SDL_CreateRGBSurfaceFrom(data->textures[i], displayMode->w, displayMode->h, bpp, pitch, Rmask, Gmask,
+                                 Bmask, Amask);
+        if (!data->screens[i]) {
+            deprintf (1, "ERROR\n");
+            PSL1GHT_DestroyRenderer(renderer);
+            return NULL;
+        }
+
+        u32 offset = 0;
+        deprintf (1,  "\t\tPrepare RSX offsets (%16X, %08X) \n", (unsigned int) data->screens[i]->pixels, (unsigned int) &offset);
+        if (rsxAddressToOffset(data->screens[i]->pixels, &offset) != 0) {
+            deprintf (1, "ERROR\n");
+            PSL1GHT_DestroyRenderer(renderer);
+            SDL_OutOfMemory();
+            return NULL;
+        }
+        
+        deprintf (1,  "\t\tSetup the display buffers\n");
+        // Setup the display buffers
+        if (gcmSetDisplayBuffer(i, offset, data->screens[i]->pitch, data->screens[i]->w, data->screens[i]->h) != 0) {
+            deprintf (1, "ERROR\n");
+            PSL1GHT_DestroyRenderer(renderer);
+            SDL_OutOfMemory();
+            return NULL;
+        }
+    }
+
+    deprintf (1,  "\tFinished\n");
+
+    renderer->CreateTexture = PSL1GHT_CreateTexture;
+    renderer->SetTextureColorMod = PSL1GHT_SetTextureColorMod;
+    renderer->SetTextureAlphaMod = PSL1GHT_SetTextureAlphaMod;
+    renderer->SetTextureBlendMode = PSL1GHT_SetTextureBlendMode;
+    renderer->UpdateTexture = PSL1GHT_UpdateTexture;
+    renderer->LockTexture = PSL1GHT_LockTexture;
+    renderer->UnlockTexture = PSL1GHT_UnlockTexture;
+    renderer->UpdateViewport = PSL1GHT_UpdateViewport;
+    renderer->DestroyTexture = PSL1GHT_DestroyTexture;
+    renderer->RenderClear = PSL1GHT_RenderClear;
+    renderer->RenderDrawPoints = PSL1GHT_RenderDrawPoints;
+    renderer->RenderDrawLines = PSL1GHT_RenderDrawLines;
+    renderer->RenderFillRects = PSL1GHT_RenderFillRects;
+    renderer->RenderCopy = PSL1GHT_RenderCopy;
+    renderer->RenderReadPixels = PSL1GHT_RenderReadPixels;
+    renderer->RenderPresent = PSL1GHT_RenderPresent;
+    renderer->DestroyRenderer = PSL1GHT_DestroyRenderer;
+    renderer->info = PSL1GHT_RenderDriver.info;
+    renderer->driverdata = data;
+
+    PSL1GHT_UpdateViewport(renderer);
+    PSL1GHT_ActivateRenderer(renderer);
+    
+    return renderer;
+}
+
+static int
+PSL1GHT_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    int bpp;
+    int pitch;
+    void *pixels;
+    Uint32 Rmask, Gmask, Bmask, Amask;
+
+    if (!SDL_PixelFormatEnumToMasks
+        (texture->format, &bpp, &Rmask, &Gmask, &Bmask, &Amask)) {
+        SDL_SetError("Unknown texture format");
+        return -1;
+    }
+
+    // Allocate GFX memory for textures
+    pitch = texture->w * SDL_BYTESPERPIXEL(texture->format);
+    pixels = rsxMemalign(64, texture->h * pitch);
+
+    texture->driverdata =
+        SDL_CreateRGBSurfaceFrom(pixels, texture->w, texture->h, bpp, pitch,
+                            Rmask, Gmask, Bmask, Amask);
+
+    SDL_SetSurfaceColorMod(texture->driverdata, texture->r, texture->g,
+                           texture->b);
+    SDL_SetSurfaceAlphaMod(texture->driverdata, texture->a);
+    SDL_SetSurfaceBlendMode(texture->driverdata, texture->blendMode);
+
+    if (!texture->driverdata) {
+        return -1;
+    }
+    return 0;
+}
+
+static int
+PSL1GHT_SetTextureColorMod(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+    return SDL_SetSurfaceColorMod(surface, texture->r, texture->g,
+                                  texture->b);
+}
+
+static int
+PSL1GHT_SetTextureAlphaMod(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+    return SDL_SetSurfaceAlphaMod(surface, texture->a);
+}
+
+static int
+PSL1GHT_SetTextureBlendMode(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+    return SDL_SetSurfaceBlendMode(surface, texture->blendMode);
+}
+
+static int
+PSL1GHT_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+                 const SDL_Rect * rect, const void *pixels, int pitch)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+    Uint8 *src, *dst;
+    int row;
+    size_t length;
+
+    if(SDL_MUSTLOCK(surface))
+        SDL_LockSurface(surface);
+
+    src = (Uint8 *) pixels;
+    dst = (Uint8 *) surface->pixels +
+                        rect->y * surface->pitch +
+                        rect->x * surface->format->BytesPerPixel;
+    length = rect->w * surface->format->BytesPerPixel;
+    for (row = 0; row < rect->h; ++row) {
+        SDL_memcpy(dst, src, length);
+        src += pitch;
+        dst += surface->pitch;
+    }
+
+    if(SDL_MUSTLOCK(surface))
+        SDL_UnlockSurface(surface);
+
+    return 0;
+}
+
+static int
+PSL1GHT_LockTexture(SDL_Renderer * renderer, SDL_Texture * texture,
+               const SDL_Rect * rect, void **pixels, int *pitch)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+
+    *pixels =
+        (void *) ((Uint8 *) surface->pixels + rect->y * surface->pitch +
+                  rect->x * surface->format->BytesPerPixel);
+    *pitch = surface->pitch;
+    return 0;
+}
+
+static void
+PSL1GHT_UnlockTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+}
+
+static int
+PSL1GHT_UpdateViewport(SDL_Renderer * renderer)
+{
+    PSL1GHT_RenderData *data = (PSL1GHT_RenderData *) renderer->driverdata;
+    SDL_Surface *surface = data->screens[0];
+
+    if (!renderer->viewport.w && !renderer->viewport.h) {
+        /* There may be no window, so update the viewport directly */
+        renderer->viewport.w = surface->w;
+        renderer->viewport.h = surface->h;
+    }
+
+    /* Center drawable region on screen */
+    if (renderer->window && surface->w > renderer->window->w) {
+        renderer->viewport.x += (surface->w - renderer->window->w)/2;
+    }
+    if (renderer->window && surface->h > renderer->window->h) {
+        renderer->viewport.y += (surface->h - renderer->window->h)/2;
+    }
+    
+    SDL_SetClipRect(data->screens[0], &renderer->viewport);
+    SDL_SetClipRect(data->screens[1], &renderer->viewport);
+    return 0;
+}
+
+static int
+PSL1GHT_RenderClear(SDL_Renderer * renderer)
+{
+    SDL_Surface *surface = PSL1GHT_ActivateRenderer(renderer);
+    Uint32 color;
+    SDL_Rect clip_rect;
+
+    if (!surface) {
+        return -1;
+    }
+
+    color = SDL_MapRGBA(surface->format,
+                        renderer->r, renderer->g, renderer->b, renderer->a);
+
+    /* By definition the clear ignores the clip rect */
+    clip_rect = surface->clip_rect;
+    SDL_SetClipRect(surface, NULL);
+    SDL_FillRect(surface, NULL, color);
+    SDL_SetClipRect(surface, &clip_rect);
+    return 0;
+}
+
+static int
+PSL1GHT_RenderDrawPoints(SDL_Renderer * renderer, const SDL_FPoint * points,
+                    int count)
+{
+    SDL_Surface *surface = PSL1GHT_ActivateRenderer(renderer);
+    SDL_Point *final_points;
+    int i, status;
+
+    if (!surface) {
+        return -1;
+    }
+
+    final_points = SDL_stack_alloc(SDL_Point, count);
+    if (!final_points) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    if (renderer->viewport.x || renderer->viewport.y) {
+        int x = renderer->viewport.x;
+        int y = renderer->viewport.y;
+
+        for (i = 0; i < count; ++i) {
+            final_points[i].x = (int)(x + points[i].x);
+            final_points[i].y = (int)(y + points[i].y);
+        }
+    } else {
+        for (i = 0; i < count; ++i) {
+            final_points[i].x = (int)points[i].x;
+            final_points[i].y = (int)points[i].y;
+        }
+    }
+
+    /* Draw the points! */
+    if (renderer->blendMode == SDL_BLENDMODE_NONE) {
+        Uint32 color = SDL_MapRGBA(surface->format,
+                                   renderer->r, renderer->g, renderer->b,
+                                   renderer->a);
+
+        status = SDL_DrawPoints(surface, final_points, count, color);
+    } else {
+        status = SDL_BlendPoints(surface, final_points, count,
+                                renderer->blendMode,
+                                renderer->r, renderer->g, renderer->b,
+                                renderer->a);
+    }
+    SDL_stack_free(final_points);
+
+    return status;
+}
+
+static int
+PSL1GHT_RenderDrawLines(SDL_Renderer * renderer, const SDL_FPoint * points,
+                   int count)
+{
+    SDL_Surface *surface = PSL1GHT_ActivateRenderer(renderer);
+    SDL_Point *final_points;
+    int i, status;
+
+    if (!surface) {
+        return -1;
+    }
+
+    final_points = SDL_stack_alloc(SDL_Point, count);
+    if (!final_points) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    if (renderer->viewport.x || renderer->viewport.y) {
+        int x = renderer->viewport.x;
+        int y = renderer->viewport.y;
+
+        for (i = 0; i < count; ++i) {
+            final_points[i].x = (int)(x + points[i].x);
+            final_points[i].y = (int)(y + points[i].y);
+        }
+    } else {
+        for (i = 0; i < count; ++i) {
+            final_points[i].x = (int)points[i].x;
+            final_points[i].y = (int)points[i].y;
+        }
+    }
+
+    /* Draw the lines! */
+    if (renderer->blendMode == SDL_BLENDMODE_NONE) {
+        Uint32 color = SDL_MapRGBA(surface->format,
+                                   renderer->r, renderer->g, renderer->b,
+                                   renderer->a);
+
+        status = SDL_DrawLines(surface, final_points, count, color);
+    } else {
+        status = SDL_BlendLines(surface, final_points, count,
+                                renderer->blendMode,
+                                renderer->r, renderer->g, renderer->b,
+                                renderer->a);
+    }
+    SDL_stack_free(final_points);
+
+    return status;
+}
+
+static int
+PSL1GHT_RenderFillRects(SDL_Renderer * renderer, const SDL_FRect * rects, int count)
+{
+    SDL_Surface *surface = PSL1GHT_ActivateRenderer(renderer);
+    SDL_Rect *final_rects;
+    int i, status;
+
+    if (!surface) {
+        return -1;
+    }
+
+    final_rects = SDL_stack_alloc(SDL_Rect, count);
+    if (!final_rects) {
+        SDL_OutOfMemory();
+        return -1;
+    }
+    if (renderer->viewport.x || renderer->viewport.y) {
+        int x = renderer->viewport.x;
+        int y = renderer->viewport.y;
+
+        for (i = 0; i < count; ++i) {
+            final_rects[i].x = (int)(x + rects[i].x);
+            final_rects[i].y = (int)(y + rects[i].y);
+            final_rects[i].w = SDL_max((int)rects[i].w, 1);
+            final_rects[i].h = SDL_max((int)rects[i].h, 1);
+        }
+    } else {
+        for (i = 0; i < count; ++i) {
+            final_rects[i].x = (int)rects[i].x;
+            final_rects[i].y = (int)rects[i].y;
+            final_rects[i].w = SDL_max((int)rects[i].w, 1);
+            final_rects[i].h = SDL_max((int)rects[i].h, 1);
+        }
+    }
+
+    if (renderer->blendMode == SDL_BLENDMODE_NONE) {
+        Uint32 color = SDL_MapRGBA(surface->format,
+                                   renderer->r, renderer->g, renderer->b,
+                                   renderer->a);
+        status = SDL_FillRects(surface, final_rects, count, color);
+    } else {
+        status = SDL_BlendFillRects(surface, final_rects, count,
+                                    renderer->blendMode,
+                                    renderer->r, renderer->g, renderer->b,
+                                    renderer->a);
+    }
+    SDL_stack_free(final_rects);
+
+    return status;
+}
+
+static int
+PSL1GHT_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
+              const SDL_Rect * srcrect, const SDL_FRect * dstrect)
+{
+    PSL1GHT_RenderData *data = (PSL1GHT_RenderData *) renderer->driverdata;
+    SDL_Surface *dst = PSL1GHT_ActivateRenderer(renderer);
+    SDL_Surface *src = (SDL_Surface *) texture->driverdata;
+    SDL_Rect final_rect;
+    u32 src_offset, dst_offset;
+
+    if (!dst) {
+        return -1;
+    }
+
+    if (renderer->viewport.x || renderer->viewport.y) {
+        final_rect.x = (int)(renderer->viewport.x + dstrect->x);
+        final_rect.y = (int)(renderer->viewport.y + dstrect->y);
+    } else {
+        final_rect.x = (int)dstrect->x;
+        final_rect.y = (int)dstrect->y;
+    }
+    final_rect.w = (int)dstrect->w;
+    final_rect.h = (int)dstrect->h;
+
+    rsxAddressToOffset(dst->pixels, &dst_offset);
+    rsxAddressToOffset(src->pixels, &src_offset);
+
+    gcmTransferScale scale;
+    scale.conversion = GCM_TRANSFER_CONVERSION_TRUNCATE;
+    scale.format = GCM_TRANSFER_SCALE_FORMAT_A8R8G8B8;
+    scale.operation = GCM_TRANSFER_OPERATION_SRCCOPY;
+    scale.clipX = final_rect.x;
+    scale.clipY = final_rect.y;
+    scale.clipW = final_rect.w;
+    scale.clipH = final_rect.h;
+    scale.outX = final_rect.x;
+    scale.outY = final_rect.y;
+    scale.outW = final_rect.w;
+    scale.outH = final_rect.h;
+    scale.ratioX = (srcrect->w << 20) / final_rect.w;
+    scale.ratioY = (srcrect->h << 20) / final_rect.h;
+    scale.inX = srcrect->x;
+    scale.inY = srcrect->y;
+    scale.inW = srcrect->w;
+    scale.inH = srcrect->h;
+    scale.offset = src_offset;
+    scale.pitch = src->pitch;
+    scale.origin = GCM_TRANSFER_ORIGIN_CORNER;
+    scale.interp = GCM_TRANSFER_INTERPOLATOR_NEAREST;
+
+    gcmTransferSurface surface;
+    surface.format = GCM_TRANSFER_SURFACE_FORMAT_A8R8G8B8;
+    surface.pitch = dst->pitch;
+    surface.offset = dst_offset;
+
+    // Hardware accelerated blit with scaling
+    rsxSetTransferScaleMode(data->context, GCM_TRANSFER_LOCAL_TO_LOCAL, GCM_TRANSFER_SURFACE);
+    rsxSetTransferScaleSurface(data->context, &scale, &surface);
+
+    // TODO: Blending / clipping
+
+    return 0;
+}
+
+static int
+PSL1GHT_RenderReadPixels(SDL_Renderer * renderer, const SDL_Rect * rect,
+                    Uint32 format, void * pixels, int pitch)
+{
+    SDL_Surface *surface = PSL1GHT_ActivateRenderer(renderer);
+    Uint32 src_format;
+    void *src_pixels;
+    SDL_Rect final_rect;
+
+    if (!surface) {
+        return -1;
+    }
+
+    if (renderer->viewport.x || renderer->viewport.y) {
+        final_rect.x = renderer->viewport.x + rect->x;
+        final_rect.y = renderer->viewport.y + rect->y;
+        final_rect.w = rect->w;
+        final_rect.h = rect->h;
+        rect = &final_rect;
+    }
+
+    if (rect->x < 0 || rect->x+rect->w > surface->w ||
+        rect->y < 0 || rect->y+rect->h > surface->h) {
+        SDL_SetError("Tried to read outside of surface bounds");
+        return -1;
+    }
+
+    src_format = surface->format->format;
+    src_pixels = (void*)((Uint8 *) surface->pixels +
+                    rect->y * surface->pitch +
+                    rect->x * surface->format->BytesPerPixel);
+
+    return SDL_ConvertPixels(rect->w, rect->h,
+                             src_format, src_pixels, surface->pitch,
+                             format, pixels, pitch);
+}
+
+static void
+PSL1GHT_RenderPresent(SDL_Renderer * renderer)
+{
+    PSL1GHT_RenderData *data = (PSL1GHT_RenderData *) renderer->driverdata;
+
+    if (!data->first_fb)
+        waitFlip();
+    else
+        gcmResetFlipStatus();
+
+    gcmSetFlip(data->context, data->current_screen);
+    rsxFlushBuffer(data->context);
+
+    gcmSetWaitFlip(data->context);
+
+    data->first_fb = false;
+
+    // Update the flipping chain, if any
+    data->current_screen = (data->current_screen + 1) % 2;
+}
+
+static void
+PSL1GHT_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
+{
+    SDL_Surface *surface = (SDL_Surface *) texture->driverdata;
+
+    // TODO: Wait for the DMA transfer to complete
+    rsxFree(surface->pixels);
+    SDL_FreeSurface(surface);
+}
+
+static void
+PSL1GHT_DestroyRenderer(SDL_Renderer * renderer)
+{
+    PSL1GHT_RenderData *data = (PSL1GHT_RenderData *) renderer->driverdata;
+    int i;
+
+    deprintf (1, "SDL_PSL1GHT_DestroyRenderer()\n");
+
+    if (data) {
+        for (i = 0; i < SDL_arraysize(data->screens); ++i) {
+            if (data->screens[i]) {
+               SDL_FreeSurface(data->screens[i]);
+            }
+            if (data->textures[i]) {
+                rsxFree(data->textures[i]);
+            }
+        }
+        SDL_free(data);
+    }
+    SDL_free(renderer);
+}
+
+#endif /* SDL_VIDEO_RENDER_PSL1GHT */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/render/SDL_render.c SDL2-2.0.1-PS3/src/render/SDL_render.c
--- SDL2-2.0.1/src/render/SDL_render.c	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/render/SDL_render.c	2013-12-06 22:07:45.962084309 -0500
@@ -65,6 +65,9 @@
 #if SDL_VIDEO_RENDER_PSP
     &PSP_RenderDriver,
 #endif
+#if SDL_VIDEO_RENDER_PSL1GHT
+    &PSL1GHT_RenderDriver,
+#endif
     &SW_RenderDriver
 };
 #endif /* !SDL_RENDER_DISABLED */
diff -burN SDL2-2.0.1/src/render/SDL_sysrender.h SDL2-2.0.1-PS3/src/render/SDL_sysrender.h
--- SDL2-2.0.1/src/render/SDL_sysrender.h	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/render/SDL_sysrender.h	2013-12-06 22:07:45.962084309 -0500
@@ -186,6 +186,9 @@
 #if SDL_VIDEO_RENDER_PSP
 extern SDL_RenderDriver PSP_RenderDriver;
 #endif
+#if SDL_VIDEO_RENDER_PSL1GHT
+extern SDL_RenderDriver PSL1GHT_RenderDriver;
+#endif
 extern SDL_RenderDriver SW_RenderDriver;
 
 #endif /* !SDL_RENDER_DISABLED */
diff -burN SDL2-2.0.1/src/test/SDL_test_fuzzer.c SDL2-2.0.1-PS3/src/test/SDL_test_fuzzer.c
--- SDL2-2.0.1/src/test/SDL_test_fuzzer.c	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/test/SDL_test_fuzzer.c	2013-12-06 22:07:45.962084309 -0500
@@ -297,7 +297,7 @@
 SDLTest_RandomUint64BoundaryValue(Uint64 boundary1, Uint64 boundary2, SDL_bool validDomain)
 {
     /* max value for Uint64 */
-    const Uint64 maxValue = ULLONG_MAX;
+    const Uint64 maxValue = UINT64_MAX;;
     return SDLTest_GenerateUnsignedBoundaryValues(maxValue,
                 (Uint64) boundary1, (Uint64) boundary2,
                 validDomain);
@@ -433,8 +433,8 @@
 SDLTest_RandomSint64BoundaryValue(Sint64 boundary1, Sint64 boundary2, SDL_bool validDomain)
 {
     /* min & max values for Sint64 */
-    const Sint64 maxValue = LLONG_MAX;
-    const Sint64 minValue = LLONG_MIN;
+    const Sint64 maxValue = SCHAR_MAX;
+    const Sint64 minValue = SCHAR_MIN;
     return SDLTest_GenerateSignedBoundaryValues(minValue, maxValue,
                 boundary1, boundary2,
                 validDomain);
diff -burN SDL2-2.0.1/src/thread/psl1ght/SDL_syssem.c SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_syssem.c
--- SDL2-2.0.1/src/thread/psl1ght/SDL_syssem.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_syssem.c	2013-12-06 22:07:45.963084298 -0500
@@ -0,0 +1,159 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Semaphores in the BeOS environment */
+
+//#include <be/kernel/OS.h>
+#include <sys/sem.h>
+#include <sys/errno.h> 
+
+#include "SDL_thread.h"
+
+
+struct SDL_semaphore
+{
+    sys_sem_t id;
+};
+
+/* Create a counting semaphore */
+SDL_sem *
+SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_sem *sem;
+	sys_sem_attr_t attr;
+
+	SDL_zero( attr);
+	attr.attr_protocol = SYS_SEM_ATTR_PROTOCOL;
+	attr.attr_pshared = SYS_SEM_ATTR_PSHARED;
+
+	sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+	if (sem) {
+		sysSemCreate( &sem->id, &attr, initial_value, 32 * 1024);
+	} else {
+		SDL_OutOfMemory();
+	}
+	return (sem);
+}
+
+/* Free the semaphore */
+void
+SDL_DestroySemaphore(SDL_sem * sem)
+{
+    if (sem) {
+		sysSemDestroy( sem->id);
+        SDL_free(sem);
+    }
+}
+
+int
+SDL_SemWaitTimeout(SDL_sem * sem, Uint32 timeout)
+{
+	int32_t val;
+	int retval;
+
+	if (!sem) {
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	int finished = 0;
+	while( finished == 0)
+	{
+		// Do not wait
+		if( timeout == 0) {
+			val = sysSemTryWait( sem->id);
+		// Wait Forever
+		} else if (timeout == SDL_MUTEX_MAXWAIT) {
+			val = sysSemWait(sem->id, 0);
+		// Wait until timeout
+		} else {
+			timeout *= 1000;     /* PS 3uses a timeout in microseconds */
+			val = sysSemWait(sem->id, timeout);
+		}
+		switch (val) {
+			case EINTR:
+				break;
+			case 0:
+				retval = 0;
+				finished = 1;
+				break;
+			case ETIMEDOUT:
+				retval = SDL_MUTEX_TIMEDOUT;
+				finished = 1;
+				break;
+			default:
+				SDL_SetError("sysSem[Try]Wait() failed");
+				retval = -1;
+				finished = 1;
+				break;
+		}
+	}
+	return retval;
+}
+
+int
+SDL_SemTryWait(SDL_sem * sem)
+{
+    return SDL_SemWaitTimeout(sem, 0);
+}
+
+int
+SDL_SemWait(SDL_sem * sem)
+{
+    return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+/* Returns the current count of the semaphore */
+Uint32
+SDL_SemValue(SDL_sem * sem)
+{
+    int32_t count;
+    Uint32 value;
+
+    value = 0;
+    if (sem) {
+		sysSemGetValue (sem->id, &count);
+        if (count > 0) {
+            value = (Uint32) count;
+        }
+    }
+    return value;
+}
+
+/* Atomically increases the semaphore's count (not blocking) */
+int
+SDL_SemPost(SDL_sem * sem)
+{
+    if (!sem) {
+        SDL_SetError("Passed a NULL semaphore");
+        return -1;
+    }
+
+    if (sysSemPost(sem->id, 1) != 0) {
+        SDL_SetError("release_sem() failed");
+        return -1;
+    }
+    return 0;
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/thread/psl1ght/SDL_systhread.c SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systhread.c
--- SDL2-2.0.1/src/thread/psl1ght/SDL_systhread.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systhread.c	2013-12-06 22:07:45.963084298 -0500
@@ -0,0 +1,137 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* PSL1GHT thread management routines for SDL */
+
+#include <stdio.h>
+#include <signal.h>
+#include <lv2/thread.h>
+#include <sys/thread.h>
+
+#include "SDL_mutex.h"
+#include "SDL_thread.h"
+#include "../SDL_thread_c.h"
+#include "../SDL_systhread.h"
+
+
+static int sig_list[] = {
+    SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGALRM, SIGTERM, SIGWINCH, 0
+};
+
+void
+SDL_MaskSignals(sigset_t * omask)
+{
+    sigset_t mask;
+    int i;
+
+    sigemptyset(&mask);
+    for (i = 0; sig_list[i]; ++i) {
+        sigaddset(&mask, sig_list[i]);
+    }
+	// FIXME as soom as signal are implemented in PSL1GHT
+//    sigprocmask(SIG_BLOCK, &mask, omask);
+}
+
+void
+SDL_UnmaskSignals(sigset_t * omask)
+{
+	// FIXME as soom as signal are implemented in PSL1GHT
+    //sigprocmask(SIG_SETMASK, omask, NULL);
+}
+
+static void
+RunThread(void *arg)
+{
+    SDL_RunThread(arg);
+	sysThreadExit(0);
+}
+
+int
+SDL_SYS_CreateThread(SDL_Thread * thread, void *args)
+{
+	sys_ppu_thread_t id;
+	size_t stack_size = 0x4000;
+	u64 priority = 1500;
+
+    /* Create the thread and go! */
+	int s = sysThreadCreate(&id, RunThread, args, priority, stack_size, THREAD_JOINABLE, "SDL");
+    thread->handle = id;
+
+    if ( s != 0)
+	{
+        SDL_SetError("Not enough resources to create thread");
+        return (-1);
+    }
+    //resume_thread(thread->handle);
+    return (0);
+}
+
+void
+SDL_SYS_SetupThread(const char *name)
+{
+    /* Set our name */
+    if (name != NULL) {
+        sys_ppu_thread_t id;
+	    sysThreadGetId(&id);
+        sysThreadRename(id, name);
+    }
+    
+    /* Mask asynchronous signals for this thread */
+    SDL_MaskSignals(NULL);
+}
+
+SDL_threadID
+SDL_ThreadID(void)
+{
+	sys_ppu_thread_t id;
+	sysThreadGetId(&id);
+    return ((SDL_threadID) id);
+}
+
+void
+SDL_SYS_WaitThread(SDL_Thread * thread)
+{
+	u64 retval;
+
+	int t = sysThreadJoin(thread->handle, &retval);
+}
+
+int
+SDL_SYS_SetThreadPriority(SDL_ThreadPriority priority)
+{
+    int value;
+
+    if (priority == SDL_THREAD_PRIORITY_LOW) {
+        value = 3000;
+    } else if (priority == SDL_THREAD_PRIORITY_HIGH) {
+        value = 1;
+    } else {
+        value = 1500;
+    }
+
+	sys_ppu_thread_t id;
+	sysThreadGetId(&id);
+	return sysThreadSetPriority(id, value);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/thread/psl1ght/SDL_systhread_c.h SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systhread_c.h
--- SDL2-2.0.1/src/thread/psl1ght/SDL_systhread_c.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systhread_c.h	2013-12-06 22:07:45.963084298 -0500
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include <signal.h>
+#include <lv2/thread.h>
+
+typedef sys_ppu_thread_t SYS_ThreadHandle;
+
+/* Functions needed to work with system threads in other portions of SDL */
+extern void SDL_MaskSignals(sigset_t * omask);
+extern void SDL_UnmaskSignals(sigset_t * omask);
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/thread/psl1ght/SDL_systls.c SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systls.c
--- SDL2-2.0.1/src/thread/psl1ght/SDL_systls.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/thread/psl1ght/SDL_systls.c	2013-12-06 22:28:46.291240419 -0500
@@ -0,0 +1,38 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "SDL_config.h"
+#include "../SDL_thread_c.h"
+
+
+SDL_TLSData *
+SDL_SYS_GetTLSData()
+{
+    return SDL_Generic_GetTLSData();
+}
+
+int
+SDL_SYS_SetTLSData(SDL_TLSData *data)
+{
+    return SDL_Generic_SetTLSData(data);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/thread/SDL_thread_c.h SDL2-2.0.1-PS3/src/thread/SDL_thread_c.h
--- SDL2-2.0.1/src/thread/SDL_thread_c.h	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/thread/SDL_thread_c.h	2013-12-06 22:07:45.964084287 -0500
@@ -38,6 +38,8 @@
 #include "windows/SDL_systhread_c.h"
 #elif SDL_THREAD_PSP
 #include "psp/SDL_systhread_c.h"
+#elif SDL_THREAD_PSL1GHT
+#include "psl1ght/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff -burN SDL2-2.0.1/src/timer/psl1ght/SDL_systimer.c SDL2-2.0.1-PS3/src/timer/psl1ght/SDL_systimer.c
--- SDL2-2.0.1/src/timer/psl1ght/SDL_systimer.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/timer/psl1ght/SDL_systimer.c	2013-12-06 22:07:45.964084287 -0500
@@ -0,0 +1,79 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_TIMER_PSL1GHT
+#include <sys/time.h>
+#include <sys/unistd.h>
+
+#include "SDL_thread.h"
+#include "SDL_timer.h"
+#include "../SDL_timer_c.h"
+
+static struct timeval start;
+
+void
+SDL_StartTicks(void)
+{
+    /* Set first ticks value */
+    gettimeofday(&start, NULL);
+}
+
+Uint32
+SDL_GetTicks(void)
+{
+    Uint32 ticks;
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    ticks =
+        (now.tv_sec - start.tv_sec) * 1000 + (now.tv_usec -
+                                              start.tv_usec) / 1000;
+    return (ticks);
+}
+
+void
+SDL_Delay(Uint32 ms)
+{
+    usleep(ms * 1000);
+}
+
+Uint64
+SDL_GetPerformanceCounter(void)
+{
+    Uint64 ticks;
+    struct timeval now;
+
+    gettimeofday(&now, NULL);
+    ticks = now.tv_sec;
+    ticks *= 1000000;
+    ticks += now.tv_usec;
+    return (ticks);
+}
+
+Uint64
+SDL_GetPerformanceFrequency(void)
+{
+    return 1000000;
+}
+
+#endif /* SDL_TIMER_PSL1GHT */
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTevents.c SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTevents.c
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTevents.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTevents.c	2013-12-06 22:07:45.965084276 -0500
@@ -0,0 +1,89 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Being a null driver, there's no event stream. We just define stubs for
+   most of the API. */
+
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_PSL1GHTvideo.h"
+#include "SDL_PSL1GHTevents_c.h"
+#include "SDL_PSL1GHTkeyboard_c.h"
+#include "SDL_PSL1GHTmouse_c.h"
+
+#include <sysutil/sysutil.h>
+
+static void eventHandle(u64 status, u64 param, void * userdata) {
+    _THIS = userdata;
+    
+    // There should only be one window
+    SDL_Window *window = _this->windows;
+
+    // Process event
+    if (status == SYSUTIL_EXIT_GAME) {
+	    deprintf(1, "Quit game requested\n");
+	    SDL_SendQuit();
+    } else if(status == SYSUTIL_MENU_OPEN) {
+	    // XMB opened
+	    if (window) {
+	        SDL_SendWindowEvent(window, SDL_WINDOWEVENT_LEAVE, 0, 0);
+	    }
+    } else if(status == SYSUTIL_MENU_CLOSE) {
+		// XMB closed
+	    if (window) {
+	        SDL_SendWindowEvent(window, SDL_WINDOWEVENT_ENTER, 0, 0);
+	    }
+    } else if(status == SYSUTIL_DRAW_BEGIN) {
+    } else if(status == SYSUTIL_DRAW_END) {
+    } else {
+	    deprintf(1, "Unhandled event: %08llX\n", (unsigned long long int)status);
+    }
+}
+
+void
+PSL1GHT_PumpEvents(_THIS)
+{
+    sysUtilCheckCallback();
+    PSL1GHT_PumpKeyboard(_this);
+    PSL1GHT_PumpMouse(_this);
+}
+
+
+void
+PSL1GHT_InitSysEvent(_THIS)
+{
+    sysUtilRegisterCallback(SYSUTIL_EVENT_SLOT0, eventHandle, _this);
+    PSL1GHT_InitKeyboard(_this);
+    PSL1GHT_InitMouse(_this);
+}
+
+void
+PSL1GHT_QuitSysEvent(_THIS)
+{
+    sysUtilUnregisterCallback(SYSUTIL_EVENT_SLOT0);
+    PSL1GHT_QuitKeyboard(_this);
+    PSL1GHT_QuitMouse(_this);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTevents_c.h SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTevents_c.h
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTevents_c.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTevents_c.h	2013-12-06 22:07:45.965084276 -0500
@@ -0,0 +1,30 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_PSL1GHTvideo.h"
+
+extern void PSL1GHT_PumpEvents(_THIS);
+extern void PSL1GHT_InitSysEvent(_THIS);
+extern void PSL1GHT_QuitSysEvent(_THIS);
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTkeyboard.c SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTkeyboard.c
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTkeyboard.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTkeyboard.c	2013-12-06 22:07:45.965084276 -0500
@@ -0,0 +1,232 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+#include "SDL_events.h"
+#include "../../events/SDL_keyboard_c.h"
+
+#include <io/kb.h>
+
+#include "SDL_PSL1GHTkeyboard_c.h"
+
+static void unicodeToUtf8(Uint16 w, char *utf8buf)
+{
+    unsigned char *utf8s = (unsigned char *) utf8buf;
+
+    if ( w < 0x0080 ) {
+        utf8s[0] = ( unsigned char ) w;
+        utf8s[1] = 0;
+    }
+    else if ( w < 0x0800 ) {
+        utf8s[0] = 0xc0 | (( w ) >> 6 );
+        utf8s[1] = 0x80 | (( w ) & 0x3f );
+        utf8s[2] = 0;
+    }
+    else {
+        utf8s[0] = 0xe0 | (( w ) >> 12 );
+        utf8s[1] = 0x80 | (( ( w ) >> 6 ) & 0x3f );
+        utf8s[2] = 0x80 | (( w ) & 0x3f );
+        utf8s[3] = 0;
+    }
+}
+
+static void updateKeymap(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    SDL_Scancode scancode;
+    SDL_Keycode keymap[SDL_NUM_SCANCODES];
+    KbConfig kbConfig;
+    KbMkey kbMkey;
+    KbLed kbLed;
+    Uint16 unicode;
+
+    SDL_GetDefaultKeymap(keymap);
+
+    ioKbGetConfiguration(0, &kbConfig);
+
+    data->_keyboardMapping = kbConfig.mapping;
+
+    kbMkey._KbMkeyU.mkeys = 0;
+    kbLed._KbLedU.leds = 1; // Num lock
+
+    // Update SDL keycodes according to the keymap
+    for (scancode = 0; scancode < SDL_NUM_SCANCODES; ++scancode) {
+
+        // Make sure this scancode is a valid character scancode
+        if (scancode == SDL_SCANCODE_UNKNOWN ||
+            scancode == SDL_SCANCODE_ESCAPE ||
+            scancode == SDL_SCANCODE_RETURN ||
+            (keymap[scancode] & SDLK_SCANCODE_MASK)) {
+            continue;
+        }
+
+        unicode = ioKbCnvRawCode(data->_keyboardMapping, kbMkey, kbLed, scancode);
+
+        // Ignore Keypad flag
+        unicode &= ~KB_KEYPAD;
+
+        // Exclude raw keys
+        if (unicode != 0 && unicode < KB_RAWDAT) {
+            keymap[scancode] = unicode;
+        }
+    }
+    SDL_SetKeymap(0, keymap, SDL_NUM_SCANCODES);
+}
+
+static void checkKeyboardConnected(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    KbInfo kbInfo;
+    ioKbGetInfo(&kbInfo);
+
+    if (kbInfo.status[0] == 1 && !data->_keyboardConnected) // Connected
+    {
+        data->_keyboardConnected = true;
+
+        // Old events in the queue are discarded
+        ioKbClearBuf(0);
+
+        // Set raw keyboard code types to get scan codes
+        ioKbSetCodeType(0, KB_CODETYPE_RAW);
+        ioKbSetReadMode(0, KB_RMODE_INPUTCHAR);
+
+        updateKeymap(_this);
+    }
+    else if (kbInfo.status[0] != 1 && data->_keyboardConnected) // Disconnected
+    {
+        data->_keyboardConnected = false;
+
+        SDL_ResetKeyboard();
+    }
+}
+
+static void updateModifierKey(bool oldState, bool newState, SDL_Scancode scancode)
+{
+    if (!oldState ^ !newState) {
+        SDL_SendKeyboardKey(newState ? SDL_PRESSED : SDL_RELEASED, scancode);
+    }
+}
+
+static void updateModifiers(_THIS, const KbData *Keys)
+{
+    SDL_Keymod modstate = SDL_GetModState();
+
+    updateModifierKey(modstate & KMOD_LSHIFT, Keys->mkey._KbMkeyU._KbMkeyS.l_shift, SDL_SCANCODE_LSHIFT);
+    updateModifierKey(modstate & KMOD_RSHIFT, Keys->mkey._KbMkeyU._KbMkeyS.r_shift, SDL_SCANCODE_RSHIFT);
+    updateModifierKey(modstate & KMOD_LCTRL, Keys->mkey._KbMkeyU._KbMkeyS.l_ctrl, SDL_SCANCODE_LCTRL);
+    updateModifierKey(modstate & KMOD_RCTRL, Keys->mkey._KbMkeyU._KbMkeyS.r_ctrl, SDL_SCANCODE_RCTRL);
+    updateModifierKey(modstate & KMOD_LALT, Keys->mkey._KbMkeyU._KbMkeyS.l_alt, SDL_SCANCODE_LALT);
+    updateModifierKey(modstate & KMOD_RALT, Keys->mkey._KbMkeyU._KbMkeyS.r_alt, SDL_SCANCODE_RALT);
+    updateModifierKey(modstate & KMOD_LGUI, Keys->mkey._KbMkeyU._KbMkeyS.l_win, SDL_SCANCODE_LGUI);
+    updateModifierKey(modstate & KMOD_RGUI, Keys->mkey._KbMkeyU._KbMkeyS.r_win, SDL_SCANCODE_RGUI);
+}
+
+static void updateKeys(_THIS, const KbData *Keys)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    int x = 0;
+    int numKeys = 0;
+    Uint8 newkeystate[SDL_NUM_SCANCODES];
+    Uint8 * keystate = SDL_GetKeyboardState(&numKeys);
+    Uint16 unicode;
+    SDL_Scancode scancode;
+
+    for (scancode = 0; scancode < SDL_NUM_SCANCODES; ++scancode) {
+        newkeystate[scancode] = SDL_RELEASED;
+    }
+
+    for (x = 0; x < Keys->nb_keycode; x++) {
+        if (Keys->keycode[0] != 0)
+            newkeystate[Keys->keycode[x]] = SDL_PRESSED;
+    }
+
+    for (scancode = 0; scancode < SDL_NUM_SCANCODES; ++scancode) {
+        if ((newkeystate[scancode] != keystate[scancode])
+                && (scancode < SDL_SCANCODE_LCTRL || scancode > SDL_SCANCODE_RGUI)) {
+
+            // Send new key state
+            SDL_SendKeyboardKey(newkeystate[scancode], scancode);
+
+            // Send the text corresponding to the keypress
+            if (newkeystate[scancode] == SDL_PRESSED) {
+                // Convert scancode
+                unicode = ioKbCnvRawCode(data->_keyboardMapping, Keys->mkey, Keys->led, scancode);
+
+                // Ignore Keypad flag
+                unicode &= ~KB_KEYPAD;
+
+                // Exclude raw keys
+                if (unicode != 0 && unicode < KB_RAWDAT) {
+                    char utf8[SDL_TEXTINPUTEVENT_TEXT_SIZE];
+
+                    // Convert from Unicode to UTF-8
+                    unicodeToUtf8(unicode, utf8);
+                    SDL_SendKeyboardText(utf8);
+                }
+            }
+        }
+    }
+}
+
+void
+PSL1GHT_PumpKeyboard(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    checkKeyboardConnected(_this);
+
+    if (data->_keyboardConnected) {
+        KbData Keys;
+
+        // Read data from the keyboard buffer
+        if (ioKbRead(0, &Keys) == 0 && Keys.nb_keycode > 0) {
+            updateModifiers(_this, &Keys);
+            updateKeys(_this, &Keys);
+        }
+    }
+}
+
+void
+PSL1GHT_InitKeyboard(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    // Init the PS3 Keyboard
+    ioKbInit(1);
+
+    data->_keyboardConnected = false;
+}
+
+void
+PSL1GHT_QuitKeyboard(_THIS)
+{
+    ioKbEnd();
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTkeyboard_c.h SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTkeyboard_c.h
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTkeyboard_c.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTkeyboard_c.h	2013-12-06 22:07:45.965084276 -0500
@@ -0,0 +1,30 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_PSL1GHTvideo.h"
+
+extern void PSL1GHT_PumpKeyboard(_THIS);
+extern void PSL1GHT_InitKeyboard(_THIS);
+extern void PSL1GHT_QuitKeyboard(_THIS);
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmodes.c SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmodes.c
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmodes.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmodes.c	2013-12-06 22:07:45.966084265 -0500
@@ -0,0 +1,183 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_PSL1GHTvideo.h"
+#include "../SDL_sysvideo.h"
+#include "SDL_timer.h"
+
+#include <sysutil/video.h>
+
+#include <assert.h>
+
+void
+PSL1GHT_InitModes(_THIS)
+{
+    deprintf(1, "+PSL1GHT_InitModes()\n");
+    SDL_DisplayMode mode;
+    PSL1GHT_DisplayModeData *modedata;
+    videoState state;
+
+    modedata = (PSL1GHT_DisplayModeData *) SDL_malloc(sizeof(*modedata));
+    if (!modedata) {
+        return;
+    }
+
+    assert(videoGetState(0, 0, &state) == 0); // Get the state of the display
+    assert(state.state == 0); // Make sure display is enabled
+
+    // Get the current resolution
+	videoResolution res;
+    assert(videoGetResolution(state.displayMode.resolution, &res) == 0);
+
+    /* Setting up the DisplayMode based on current settings */
+    mode.format = SDL_PIXELFORMAT_ARGB8888;
+    mode.refresh_rate = 0;
+    mode.w = res.width;
+    mode.h = res.height;
+
+    modedata->vconfig.resolution = state.displayMode.resolution;
+    modedata->vconfig.format = VIDEO_BUFFER_FORMAT_XRGB;
+    modedata->vconfig.pitch = res.width * 4;
+    mode.driverdata = modedata;
+
+    /* Setup the display to it's  default mode */
+    assert(videoConfigure(0, &modedata->vconfig, NULL, 1) == 0);
+
+	// Wait until RSX is ready
+	do{
+		SDL_Delay(10);
+		assert( videoGetState(0, 0, &state) == 0);
+	}while ( state.state == 3);
+
+    /* Set display's videomode and add it */
+    SDL_AddBasicVideoDisplay(&mode);
+
+    deprintf(1, "-PSL1GHT_InitModes()\n");
+}
+
+/* DisplayModes available on the PS3 */
+static SDL_DisplayMode ps3fb_modedb[] = {
+    /* Native resolutions (progressive, "fullscreen") */
+    {SDL_PIXELFORMAT_ARGB8888, 1920, 1080, 0, NULL}, // 1080p
+    {SDL_PIXELFORMAT_ARGB8888, 1280, 720, 0, NULL}, // 720p
+    {SDL_PIXELFORMAT_ARGB8888, 720, 480, 0, NULL}, // 480p
+    {SDL_PIXELFORMAT_ARGB8888, 720, 576, 0, NULL}, // 576p
+};
+
+/* PS3 videomode number according to ps3fb_modedb */
+static PSL1GHT_DisplayModeData ps3fb_data[] = {
+	// { resolution, format, aspect, padding, pitch }
+	{{
+		VIDEO_RESOLUTION_1080, 
+		VIDEO_BUFFER_FORMAT_XRGB,
+		VIDEO_ASPECT_16_9, 
+		{0, 0, 0, 0, 0, 0, 0, 0, 0},
+		1920 * 4
+	}},
+	{{
+		VIDEO_RESOLUTION_720, 
+		VIDEO_BUFFER_FORMAT_XRGB,
+		VIDEO_ASPECT_16_9, 
+		{0, 0, 0, 0, 0, 0, 0, 0, 0},
+		1280 * 4
+	}},
+	{{
+		VIDEO_RESOLUTION_480, 
+		VIDEO_BUFFER_FORMAT_XRGB,
+		VIDEO_ASPECT_16_9, 
+		{0, 0, 0, 0, 0, 0, 0, 0, 0},
+		720 * 4
+	}},
+	{{
+		VIDEO_RESOLUTION_576, 
+		VIDEO_BUFFER_FORMAT_XRGB,
+		VIDEO_ASPECT_16_9, 
+		{0, 0, 0, 0, 0, 0, 0, 0, 0},
+		720 * 4
+	}},
+};
+
+void
+PSL1GHT_GetDisplayModes(_THIS, SDL_VideoDisplay * display)
+{
+    deprintf(1, "+PSL1GHT_GetDisplayModes()\n");
+    unsigned int nummodes;
+
+    nummodes = sizeof(ps3fb_modedb) / sizeof(SDL_DisplayMode);
+
+    int n;
+    for (n=0; n<nummodes; ++n) {
+        /* Get driver specific mode data */
+        ps3fb_modedb[n].driverdata = &ps3fb_data[n];
+
+        /* Add DisplayMode to list */
+        deprintf(2, "Adding resolution %u x %u\n", ps3fb_modedb[n].w, ps3fb_modedb[n].h);
+        SDL_AddDisplayMode(display, &ps3fb_modedb[n]);
+    }
+    deprintf(1, "-PSL1GHT_GetDisplayModes()\n");
+}
+
+int
+PSL1GHT_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode)
+{
+    deprintf(1, "+PSL1GHT_SetDisplayMode()\n");
+    PSL1GHT_DisplayModeData *dispdata = (PSL1GHT_DisplayModeData *) mode->driverdata;
+	videoState state;
+
+    /* Set the new DisplayMode */
+    deprintf(2, "Setting PS3_MODE to %u\n", dispdata->vconfig.resolution);
+    if ( videoConfigure(0, &dispdata->vconfig, NULL, 0) != 0)
+	{
+        deprintf(2, "Could not set PS3FB_MODE\n");
+        SDL_SetError("Could not set PS3FB_MODE\n");
+        return -1;
+    }
+
+	// Wait until RSX is ready
+	do{
+		SDL_Delay(10);
+		assert( videoGetState(0, 0, &state) == 0);
+	}while ( state.state == 3);
+
+    deprintf(1, "-PSL1GHT_SetDisplayMode()\n");
+    return 0;
+}
+
+void
+PSL1GHT_QuitModes(_THIS)
+{
+    deprintf(1, "+PSL1GHT_QuitModes()\n");
+
+    /* There was no mem allocated for driverdata */
+    int i, j;
+    for (i = 0; i < SDL_GetNumVideoDisplays(); ++i) {
+        SDL_VideoDisplay *display = &_this->displays[i];
+        for (j = display->num_display_modes; j--;) {
+            display->display_modes[j].driverdata = NULL;
+        }
+    }
+    // TODO : Free data
+    deprintf(1, "-PSL1GHT_QuitModes()\n");
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmodes_c.h SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmodes_c.h
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmodes_c.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmodes_c.h	2013-12-06 22:07:45.966084265 -0500
@@ -0,0 +1,35 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_psl1ghtmodes_h
+#define _SDL_psl1ghtmodes_h
+
+extern void PSL1GHT_InitModes(_THIS);
+extern void PSL1GHT_GetDisplayModes(_THIS, SDL_VideoDisplay * display);
+extern int PSL1GHT_SetDisplayMode(_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode);
+extern void PSL1GHT_QuitModes(_THIS);
+
+
+#endif /* SDL_psl1ghtmodes_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmouse.c SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmouse.c
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmouse.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmouse.c	2013-12-06 22:07:45.966084265 -0500
@@ -0,0 +1,139 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+#include "SDL_events.h"
+#include "../../events/SDL_mouse_c.h"
+
+#include <io/mouse.h>
+
+#include "SDL_PSL1GHTmouse_c.h"
+
+void checkMouseConnected(_THIS) {
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    mouseInfo mouseinfo;
+    ioMouseGetInfo(&mouseinfo);
+
+    if (mouseinfo.status[0] == 1 && !data->_mouseConnected) // Connected
+    {
+        data->_mouseConnected = SDL_TRUE;
+        data->_mouseButtons = 0;
+
+        // Old events in the queue are discarded
+        ioMouseClearBuf(0);
+    }
+    else if (mouseinfo.status[0] != 1 && data->_mouseConnected) // Disconnected
+    {
+        data->_mouseConnected = SDL_FALSE;
+        data->_mouseButtons = 0;
+    }
+}
+
+void updateMouseButtons(_THIS, int mouseId, const mouseData *mouse) {
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+    // There should only be one window
+    SDL_Window *window = _this->windows;
+
+    // Check left mouse button changes
+    SDL_bool oldLMB = data->_mouseButtons & 1;
+    SDL_bool newLMB = mouse->buttons & 1;
+    if (newLMB != oldLMB) {
+        SDL_SendMouseButton(window, mouseId, newLMB ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_LEFT);
+    }
+
+    // Check rigth mouse button changes
+    SDL_bool oldRMB = data->_mouseButtons & 2;
+    SDL_bool newRMB = mouse->buttons & 2;
+    if (newRMB != oldRMB) {
+        SDL_SendMouseButton(window, mouseId, newRMB ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_RIGHT);
+    }
+
+    // Check middle mouse button changes
+    SDL_bool oldMMB = data->_mouseButtons & 4;
+    SDL_bool newMMB = mouse->buttons & 4;
+    if (newMMB != oldMMB) {
+        SDL_SendMouseButton(window, mouseId, newMMB ? SDL_PRESSED : SDL_RELEASED, SDL_BUTTON_MIDDLE);
+    }
+
+    data->_mouseButtons = mouse->buttons;
+}
+
+void updateMousePosition(_THIS, int mouseId, const mouseData *mouse) {
+    // There should only be one window
+    SDL_Window *window = _this->windows;
+
+    // Mouse movement is relative
+    SDL_SendMouseMotion(window, mouseId, 1, mouse->x_axis, mouse->y_axis);
+}
+
+void updateMouseWheel(_THIS, int mouseId, const mouseData *mouse) {
+    // There should only be one window
+    SDL_Window *window = _this->windows;
+
+    SDL_SendMouseWheel(window, mouseId, mouse->tilt, mouse->wheel);
+}
+
+void
+PSL1GHT_PumpMouse(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    // Check if a mouse has been connected / disconnected
+    checkMouseConnected(_this);
+
+    if (data->_mouseConnected)
+    {
+        mouseDataList datalist;
+        ioMouseGetDataList(0, &datalist);
+
+        int i;
+        for (i = 0; i < datalist.count; i++) {
+            // Send SDL events
+            updateMouseButtons(_this, 0, &datalist.list[i]);
+            updateMousePosition(_this, 0, &datalist.list[i]);
+            updateMouseWheel(_this, 0, &datalist.list[i]);
+        }
+    }
+}
+
+void
+PSL1GHT_InitMouse(_THIS)
+{
+    SDL_DeviceData *data =
+        (SDL_DeviceData *) _this->driverdata;
+
+    // Support only one mouse for now
+    ioMouseInit(1);
+
+    data->_mouseConnected = SDL_FALSE;
+}
+
+void
+PSL1GHT_QuitMouse(_THIS)
+{
+    ioMouseEnd();
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmouse_c.h SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmouse_c.h
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTmouse_c.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTmouse_c.h	2013-12-06 22:07:45.966084265 -0500
@@ -0,0 +1,30 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_PSL1GHTvideo.h"
+
+extern void PSL1GHT_PumpMouse(_THIS);
+extern void PSL1GHT_InitMouse(_THIS);
+extern void PSL1GHT_QuitMouse(_THIS);
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTvideo.c SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTvideo.c
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTvideo.c	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTvideo.c	2013-12-06 22:07:45.967084254 -0500
@@ -0,0 +1,153 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* PSL1GHT SDL video driver implementation (for PS3). Based on Dummy driver.
+ *
+ * Initial work by Ryan C. Gordon (icculus@icculus.org). A good portion
+ *  of this was cut-and-pasted from Stephane Peter's work in the AAlib
+ *  SDL video driver.  Renamed to "DUMMY" by Sam Lantinga.
+ */
+
+#include "SDL_video.h"
+#include "SDL_mouse.h"
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_PSL1GHTvideo.h"
+#include "SDL_PSL1GHTevents_c.h"
+#include "SDL_PSL1GHTmodes_c.h"
+
+
+#include <malloc.h>
+#include <assert.h>
+#include <unistd.h>
+
+#include <rsx/rsx.h>
+
+#define PSL1GHTVID_DRIVER_NAME "psl1ght"
+
+/* Initialization/Query functions */
+static int PSL1GHT_VideoInit(_THIS);
+static void PSL1GHT_VideoQuit(_THIS);
+
+/* PS3GUI init functions : */
+static void initializeGPU(SDL_DeviceData * devdata);
+
+/* PSL1GHT driver bootstrap functions */
+
+static int
+PSL1GHT_Available(void)
+{
+    return (1);
+}
+
+static void
+PSL1GHT_DeleteDevice(SDL_VideoDevice * device)
+{
+    deprintf (1, "PSL1GHT_DeleteDevice( %16X)\n", device);
+    SDL_free(device);
+}
+
+static SDL_VideoDevice *
+PSL1GHT_CreateDevice(int devindex)
+{
+    SDL_VideoDevice *device;
+    deprintf (1, "PSL1GHT_CreateDevice( %16X)\n", devindex);
+
+    /* Initialize all variables that we clean on shutdown */
+    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
+    if (device) {
+        SDL_memset(device, 0, (sizeof *device));
+    }
+    else {
+        SDL_OutOfMemory();
+        SDL_free(device);
+        return (0);
+    }
+
+    /* Set the function pointers */
+    device->VideoInit = PSL1GHT_VideoInit;
+    device->VideoQuit = PSL1GHT_VideoQuit;
+    device->SetDisplayMode = PSL1GHT_SetDisplayMode;
+    device->GetDisplayModes = PSL1GHT_GetDisplayModes;
+    device->PumpEvents = PSL1GHT_PumpEvents;
+
+    device->free = PSL1GHT_DeleteDevice;
+
+    return device;
+}
+
+VideoBootStrap PSL1GHT_bootstrap = {
+    PSL1GHTVID_DRIVER_NAME, "SDL psl1ght video driver",
+    PSL1GHT_Available, PSL1GHT_CreateDevice
+};
+
+int
+PSL1GHT_VideoInit(_THIS)
+{
+    SDL_DeviceData *devdata = NULL;
+
+    devdata = (SDL_DeviceData*) SDL_calloc(1, sizeof(SDL_DeviceData));
+    if (devdata == NULL) { 
+        /* memory allocation problem */  
+        SDL_OutOfMemory();
+        return -1;
+    } 
+
+    _this->driverdata = devdata;
+
+    PSL1GHT_InitSysEvent(_this);
+
+    initializeGPU(devdata);
+    PSL1GHT_InitModes(_this);
+
+    gcmSetFlipMode(GCM_FLIP_VSYNC); // Wait for VSYNC to flip
+
+    /* We're done! */
+    return 0;
+}
+
+void
+PSL1GHT_VideoQuit(_THIS)
+{
+    deprintf (1, "PSL1GHT_VideoQuit()\n");
+    PSL1GHT_QuitModes(_this);
+    PSL1GHT_QuitSysEvent(_this);
+    SDL_free( _this->driverdata);
+
+}
+
+void initializeGPU( SDL_DeviceData * devdata)
+{
+    deprintf (1, "initializeGPU()\n");
+   // Allocate a 1Mb buffer, alligned to a 1Mb boundary to be our shared IO memory with the RSX.
+    void *host_addr = memalign(1024*1024, 1024*1024);
+    assert(host_addr != NULL);
+
+    // Initilise Reality, which sets up the command buffer and shared IO memory
+    devdata->_CommandBuffer = rsxInit(0x10000, 1024*1024, host_addr);
+    assert(devdata->_CommandBuffer != NULL);
+}
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTvideo.h SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTvideo.h
--- SDL2-2.0.1/src/video/psl1ght/SDL_PSL1GHTvideo.h	1969-12-31 19:00:00.000000000 -0500
+++ SDL2-2.0.1-PS3/src/video/psl1ght/SDL_PSL1GHTvideo.h	2013-12-06 22:07:45.967084254 -0500
@@ -0,0 +1,73 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2010 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_PSL1GHTvideo_h
+#define _SDL_PSL1GHTvideo_h
+
+#include "../SDL_sysvideo.h"
+
+#include <rsx/rsx.h>
+#include <sysutil/video.h>
+
+/* Debugging
+ * 0: No debug messages
+ * 1: Video debug messages
+ * 2: SPE debug messages
+ * 3: Memory adresses
+ */
+//#define VIDEO_DEBUG_LEVEL 0
+
+#ifdef VIDEO_DEBUG_LEVEL
+#define deprintf( level, fmt, args... ) \
+    do \
+{ \
+    if ( (unsigned)(level) <= VIDEO_DEBUG_LEVEL ) \
+    { \
+        fprintf( stdout, fmt, ##args ); \
+        fflush( stdout ); \
+    } \
+} while ( 0 )
+#else
+#define deprintf( level, fmt, args... )
+#endif
+
+/* Private RSX data */
+typedef struct SDL_DeviceData
+{
+    // Context to keep track of the RSX buffer.
+    gcmContextData *_CommandBuffer;
+
+    SDL_bool _keyboardConnected;
+    Uint32 _keyboardMapping;
+
+    SDL_bool _mouseConnected;
+    Uint8 _mouseButtons;
+} SDL_DeviceData;
+
+typedef struct SDL_DisplayModeData
+{
+    videoConfiguration vconfig;
+} PSL1GHT_DisplayModeData;
+#endif /* _SDL_PSL1GHTvideo_h */
+
+/* vi: set ts=4 sw=4 expandtab: */
diff -burN SDL2-2.0.1/src/video/SDL_sysvideo.h SDL2-2.0.1-PS3/src/video/SDL_sysvideo.h
--- SDL2-2.0.1/src/video/SDL_sysvideo.h	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/video/SDL_sysvideo.h	2013-12-06 22:07:45.968084243 -0500
@@ -363,6 +363,9 @@
 #if SDL_VIDEO_DRIVER_PSP
 extern VideoBootStrap PSP_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_PSL1GHT
+extern VideoBootStrap PSL1GHT_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_RPI
 extern VideoBootStrap RPI_bootstrap;
 #endif
diff -burN SDL2-2.0.1/src/video/SDL_video.c SDL2-2.0.1-PS3/src/video/SDL_video.c
--- SDL2-2.0.1/src/video/SDL_video.c	2013-10-24 00:05:29.000000000 -0400
+++ SDL2-2.0.1-PS3/src/video/SDL_video.c	2013-12-06 22:07:45.969084232 -0500
@@ -80,6 +80,9 @@
 #if SDL_VIDEO_DRIVER_PSP
     &PSP_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_PSL1GHT
+    &PSL1GHT_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_RPI
     &RPI_bootstrap,
 #endif 
